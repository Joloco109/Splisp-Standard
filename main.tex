\documentclass{scrartcl}

\usepackage{stysty}

\title{Eventteam RFC 1 - Splisp(kell)}
\author{Samuel Mahler, \\
        Philipp Rosendahl, \\
        Jonas Colve}
\date{December 2019}

\counterwithin*{section}{part}






\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\parindent0pt

\part{Introduction}

\section{Demotivation}

\epigraph{C++ stinks, and Rust is powerless. Haskell is ugly af. No one likes Lisp.}{\textit{Samuel Mahler}}

This is why we pitch to you this language, which hopefully we have implemented by the time you read this. Probably not. Nonetheless, here are the ideas we have for this language:

\begin{itemize}
    \item It's pure functional
    \item It's statically typed
    \item Variadically typed templating
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{l|c}
        Feature                     & Value \\ \hline
        Iteration                   & NO    \\
        Inheritance                 & NO    \\
        Structs                     & YES   \\
        Lists                       & YES   \\
        Traits                      & YES   \\
        Functions                   & YES   \\
        Rust-like pattern matching  & YES   \\
        List comprehensions         & YES   \\
        Function overloading        & NO    \\
        Trait overloading           & YES\footnotemark   \\
        Fold expressions over Lists & MAYBE
    \end{tabular}
    \caption{Language features}
\end{table}

\footnotetext{Wouldn't be much of a Trait system, would it?}

\part{Grammar}

\section{Lists}

Splisp is, at it's core, a list-based language (never could've guessed that, could'ya?). Differently declared lists have very different meanings in Splisp, and it is vital that you know what kind of list does what:

\begin{itemize}
	\item[Parenthesised lists:] () \newline
	These lists are used to declare a pattern of variables of specific types, such as in function declarations or composite patterns used for declaring the type of a function (think, Haskell: \lstinline|(i8, f32) -> (std.string)|). Elements of the list are delimited by a comma.
	\item[Braces:] \{\} (Colloquially curly brackets) \newline
	Used to implement code. You write code in here. It's like C. (Or, if you are an idiot, like Java) It's a list of statements.
	\item[Chevroned lists:] \textless\textgreater\ (Colloquially angle brackets) \newline
	These are similar to the parenthesised lists, but they are for metapatterns. This means they can match a list of types. Elements of the list are delimited by a comma. Specific usage is explained later, so ignore examples from here on until you understand how they work.
	\item[Bracketed lists:] [] (Colloquially square brackets) \newline
	These are used for instantiations of either parenthesised or chevroned lists. It is very much like you would expect (\lstinline|[i8, f32, std.string]| for types or \lstinline|[23, 500.1234, "Baguette"]| for a matching set of variables). Elements of this list are delimited by a comma.
\end{itemize}

But there's more: Pattern - matching lists (i.e. parenthesised and chevroned lists) can have the last entry repeating. This is done by virtue of a trailing comma. Examples:
\begin{itemize}
	\item \lstinline|[25, "Baguette", "Avec", "Fromage"]| matches \lstinline|(i8, std.string,)| as well as \lstinline|(i8, std.string, std.string,)| \lstinline|(i8, std.string, std.string, std.string,)| and \lstinline|(i8, std.string, std.string, std.string)| (Note the last one omitting the trailing comma, making the amount of allowed parameters fixed)
	\item \lstinline|[i8, std.string, std.string]| matches \lstinline|<*, *,>| and \lstinline|<*, *, *>|, but \textbf{not} \lstinline|<*,>|
\end{itemize}

The elements of pattern - matching lists are often given a name to be able to refer to them in function  or type definitons. While not wanting to dive too deeply into usage at this point, these names are given by first stating the name and then the to-be matched part of the pattern. Examples:

\begin{itemize}
	\item \lstinline|(ubound:f32, lbound:f32)|
	\item \lstinline|<T:incrementable, U:<storable,>>| $\leftarrow$ Watch out! This one also uses type traits instead of \lstinline|*|s!
\end{itemize}

\subsection{Handling lists}

For lists, exactly one operator exists to handle them. This is the octothorpe operator, in short "thorperator". It takes a list and makes the exterior pattern match take the lists elements as single entries in the pattern match. Example:

\smallskip

\begin{lstlisting}
let x:(i32, f32, std.string, f64) = [-200, -3.123, "ohgodsendhalp", 0.123456789]
f:(std.string, i32, i32, f32, std.string, f64) -> i32 = func (std.string, i32, i32, f32, std.string, f64) { 0 }
f["plsno", 25555, #x]
\end{lstlisting}

%\section{On structure}

%This section has already been written, but I currently don't have access to it. Sorry.

%\section{Types}

%\section{Traits}

%\section{Functions}


\end{document}
