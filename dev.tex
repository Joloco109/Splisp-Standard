\documentclass{scrartcl}

\usepackage{stysty}

\title{Eventteam RFC 1 - Splisp(kell)}
\author{Samuel Mahler, \\
        Philipp Rosendahl, \\
        Jonas Colve}
\date{December 2019}

\counterwithin*{section}{part}






\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\part{Introduction}

\section{Demotivation}

\epigraph{C++ stinks, and Rust is powerless. Haskell is ugly af. No one likes Lisp.}{\textit{Samuel Mahler}}

This is why we pitch to you this language, which hopefully we have implemented by the time you read this. Probably not. Nonetheless, here are the ideas we have for this language:

\begin{itemize}
    \item It's pure functional
    \item It's statically typed
    \item Variadically typed templating
\end{itemize}

\begin{table}[H]
    \centering
    \begin{tabular}{l|c}
        Feature                     & Value \\ \hline
        Iteration                   & NO    \\
        Inheritance                 & NO    \\
        Structs                     & YES   \\
        Lists                       & YES   \\
        Traits                      & YES   \\
        Functions                   & YES   \\
        Rust-like pattern matching  & YES   \\
        List comprehensions         & YES   \\
        Function overloading        & NO    \\
        Trait overloading           & YES\footnotemark   \\
    \end{tabular}
    \caption{Language features}
\end{table}

\footnotetext{Wouldn't be much of a Trait system, would it?}

The official name of the language is derived from the word spliff and the name of the "popular" programming language LISP, indicating that you have to be pretty high to use this language productively. The alternative name coined by Samuel Mahler is Spazzkell, warning the potential user of the allegedly "spazzy" language.




\part{Grammar}

\section{Lists}

Splisp is, at it's core, a list-based language (never could've guessed that, could you?). Lists can be declared by use of the following types of brackets:

\begin{itemize}
    \item[Parentheses:] () \newline
        Used to declare a list of a collection of THINGS, 
    \item[Braces:] \{\} \newline
        Used to explicitly define an expression.
    \item[Chevrons:] \textless\textgreater\ (Also called angle brackets) \newline
        Used to 
    \item[Brackets:] [] (Also called square brackets) \newline
        Used for indexed list access and list comprehesions.
\end{itemize}

\section{Expression}

\subsection{Simple Expressions}

Simple expressions are function calls or unary or binary operators. They have they can have any number of arguments and a distinct return value.

%\subsection{General Expressions}
\medskip

Generally, simple expressions can be composed from other simple expressions by applying a simple expression to the result of another simple expression.

\subsection{Statement}

A statement consists of the following components:

\begin{itemize}
    \item the keyword \texttt{let}
    \item the identifier aka name
    \item a colon, followed by the "return type" of the statement
    \item the equality sign \texttt{=}
    \item the expression (you are also allowed to use expressions with statements) the identifier is bound to, followed by a semicolon
\end{itemize}

\begin{lstlisting}
let x:float = 5;
let y:float = 3.4 / x;
let z := 3.4;
\end{lstlisting}

\begin{lstlisting}
expression        = ( LET ident COLON ident EQUALS expression)*
                      simple_expression
simple_expression = func_call | bin_op | un_op | literal
func_call         = ident LBR expression ( COMMA expression )* RBR
bin_op            = expression opident expression
un_op             = ( opident expression | expression opident )
ident             = (a-z|_)(a-z|0-9|_)ex*
opident           = .*
\end{lstlisting}

\subsection{Expressions}
An expressions consists of zero or more statements und is finished by a simple expression.

\section{Functions}

Functions are of the Kind (*) -> *

\section{Types}

\subsection{Methods}

\section{Traits}





\part{Reference of basic language features}

\section{Operators (language-inherent types)}

%Operators are applied to expressions in the following fashion: For an expression \texttt{E}, 

For the language-inherent types, a set of operators performs a given set of operations on these types. The language-inherent 

Arithmetic operations perform on 

\begin{table}[H]
    \centering
    \begin{tabular}{c|c|c}
    \multicolumn{3}{c}{Unary arithmetic operators} \\ \hline
        - & operator-()         & Invert \\ \hline
    \multicolumn{3}{c}{Binary arithmetic operators} \\ \hline
        + & operator+(other)    & Add \\
        - & operator-(other)    & Sub \\
        $*$ & operator*(other)  & Mul \\
        / & operator/(other)    & Div \\
    \multicolumn{3}{c}{Unary logical operators} \\ \hline
        
    \end{tabular}
\end{table}


\part{Standard Library}

In the following context, the phrase "language-inherent" does NOT imply the constructs have to exist in the language itself, but rather that the respective parts of the library do not have to be imported manually.

\section{Basic "language-inherent" types}

\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
    \multicolumn{2}{c}{Integral types} \\ \hline
        i8 & Signed 8 bit integer \\
        i16 & Signed 16 bit integer \\
        i32 & Signed 32 bit integer \\
        i64 & Signed 64 bit integer \\
        u8 & Unsigned 8 bit integer \\
        u16 & Unsigned 16 bit integer \\
        u32 & Unsigned 32 bit integer \\
        u64 & Unsigned 64 bit integer \\ \hline
    \multicolumn{2}{c}{Floating-point types} \\ \hline
        f32 & Single-precision IEEE 754-2008 floating point number \\
        f64 & Double-precision IEEE 754-2008 floating point number \\
        f80 & Extended-precision IEEE 754-2008 floating point number \\
        f128 & Either $\equiv$ f80 or Quad-precision IEEE 754-2008 floating point number \\ \hline
        bool & 1-bit Boolean type \\ \hline
        char & 8-bit character \\
        uchar & 1 Unicode character representation 
    \end{tabular}
\end{table}

\section{Basic "language-inherent" type traits}

\begin{table}[H]
    \centering
    \begin{tabular}{c|c}
        add & Addition must be supported \\
         & 
    \end{tabular}
\end{table}

\end{document}
